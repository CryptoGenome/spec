
\section{Tendermint consensus algorithm}
\label{sec:tendermint}

\newcommand\Disseminate{\textbf{Disseminate}}

\newcommand\Proposal{\mathsf{PROPOSAL}}
\newcommand\ProposalPart{\mathsf{PROPOSAL\mbox{-}PART}}
\newcommand\PrePrepare{\mathsf{INIT}}
\newcommand\Prevote{\mathsf{PREVOTE}}
\newcommand\Precommit{\mathsf{PRECOMMIT}}
\newcommand\Decision{\mathsf{DECISION}}

\newcommand\ViewChange{\mathsf{VC}}
\newcommand\ViewChangeAck{\mathsf{VC\mbox{-}ACK}}
\newcommand\NewPrePrepare{\mathsf{VC\mbox{-}INIT}}
\newcommand\coord{\mathsf{proposer}}

\newcommand\newHeight{newHeight}
\newcommand\newRound{newRound}
\newcommand\nil{nil}
\newcommand\id{id}
\newcommand{\propose}{propose}
\newcommand\prevote{prevote}
\newcommand\prevoteWait{prevoteWait}
\newcommand\precommit{precommit}
\newcommand\precommitWait{precommitWait}
\newcommand\commit{commit}

\newcommand\timeoutPropose{timeoutPropose}
\newcommand\timeoutPrevote{timeoutPrevote}
\newcommand\timeoutPrecommit{timeoutPrecommit}
\newcommand\proofOfLocking{proof\mbox{-}of\mbox{-}locking}

\begin{algorithm}[htb!]
\def\baselinestretch{1}
\scriptsize\raggedright
\begin{algorithmic}[1]
	\SHORTSPACE
\INIT{}
\STATE $h_p := 0$ \COMMENT{current height, or consensus instance we are currently executing}
\STATE $round_p := 0$   \COMMENT{current round number} 
\STATE $step_p  \in \set{\propose=0, \prevote=1, \prevoteWait=2, \precommit=3}$, initially $\propose$  
\STATE $decision_p[] := nil$ for every element of the array
\STATE $lockedValue_p := nil$
\STATE $lockedRound_p := -1$ 
\STATE $validValue_p := nil$
\STATE $validRound_p := -1$
%\STATE ~~$\timeoutPropose := initTimeoutPropose + r*timeoutDelta$
%\STATE ~~$\timeoutPrevote := initTimeoutPrevote + r*timeoutDelta$
%\STATE $\timeoutPrecommit := initTimeoutPrecommit + r*timeoutDelta$
\ENDINIT
\SHORTSPACE
\STATE \textbf{upon} start \textbf{do}  $StartRound(0)$
\SHORTSPACE
\FUNCTION{$StartRound(round)$} \label{line:tab:startRound}
	\STATE	$round_p \assign round$
	\STATE	$step_p \assign \propose$
	\IF{$\coord(h_p, round_p) = p$} 
		\IF{$validValue_p \neq \nil$} \label{line:tab:isThereLockedValue}
			\STATE $proposal \assign validValue_p$
		\ELSE
			\STATE $proposal \assign getValue()$ \label{line:tab:getValidValue}
		\ENDIF 	  
		\STATE \Broadcast\ $\li{\Proposal,h_p, round_p, proposal, validRound_p}$  \label{line:tab:send-proposal}
	\ELSE
		\STATE \textbf{after} $\timeoutPropose$ execute $OnTimeoutPropose(h_p, round_p)$ 
	\ENDIF
\ENDFUNCTION

\SPACE
\UPON{$\li{\Proposal,h_p,round_p, v, r}$ \From\ $\coord(h_p,round_p)$ \With\ $state_p = \propose$} \label{line:tab:recvProposal}			
 \IF{$!valid(v) \vee (lockedRound_p > r  \wedge lockedValue_p \neq v$)}  \label{line:tab:acceptProposal1}		
 	\STATE \Broadcast \ $\li{\Prevote,h_p,round_p,\nil}$  \label{line:tab:prevote-nil}	
 	\STATE $step_p \assign \prevote$ \label{line:tab:setStateToPrevote1} 
 \ELSIF{$valid(v) \wedge (lockedRound_p = -1  \vee lockedValue_p = v$)} \label{line:tab:accept-proposal-2}
 	\STATE \Broadcast \ $\li{\Prevote,h_p,round_p,id(v)}$  \label{line:tab:prevote-proposal}	
 	\STATE $step_p \assign \prevote$ \label{line:tab:setStateToPrevote2} 
 \ENDIF
\ENDUPON

\SPACE
\UPON{$\li{\Proposal,h_p,round_p, v, r}$ \From\ $\coord(h_p,round_p)$ \textbf{AND} $2f+1$ $\li{\Prevote,h_p, r,id(v)}$  \With\
	$step_p = \propose$} \label{line:tab:acceptProposal}
	\IF{$r \ge lockedRound_p \wedge r < round_p \wedge valid(v)$} \label{line:tab:cond-prevote-higher-proposal}	
		\STATE \Broadcast \ $\li{\Prevote,h_p,round_p,id(v)}$  \label{line:tab:prevote-higher-proposal}	
		\STATE $step_p \assign \prevote$ \label{line:tab:setStateToPrevote3} 		 
	\ENDIF
\ENDUPON

\SPACE
\UPON{$2f+1$ $\li{\Prevote,h_p, round_p,*}$ \With\ $state_p = \prevote$} \label{line:tab:recvAny2/3Prevote}
	\STATE \textbf{after} $\timeoutPrevote$ execute $OnTimeoutPrevote(h_p, round_p)$ \label{line:tab:timeoutPrevote}
		\STATE $step_p \assign \prevoteWait$ \label{line:tab:setStateToPrevoteWait} 
\ENDUPON

\SPACE
\UPON{$\li{\Proposal,h_p,round_p, v, *}$ \From\ $\coord(h_p,round_p)$ \textbf{AND} $2f+1$ $\li{\Prevote,h_p, round_p,id(v)}$  \With\ $valid(v)$} \label{line:tab:recvPrevote}
	\IF{$step_p = \prevote$}	
	\STATE $lockedValue_p \assign v$                \label{line:tab:setLockedValue}
	\STATE $lockedRound_p \assign round_p$   \label{line:tab:setLockedRound} 
	\STATE \Broadcast \ $\li{\Precommit,h_p,round_p,id(v))}$  \label{line:tab:precommit-v}	
	\STATE $step_p \assign \precommit$ \label{line:tab:setStateToCommit}
	\ENDIF
	\STATE $validValue_p \assign v$                          \label{line:tab:setValidRound}
	\STATE $validRound_p \assign round_p$             \label{line:tab:setValidValue}
\ENDUPON

\SHORTSPACE
\UPON{$2f+1$ $\li{\Prevote,h_p,round_p, \nil}$ \With\ $state_p = \prevote$}
	\STATE \Broadcast \ $\li{\Precommit,h_p,round_p, \nil}$   \label{line:tab:precommit-v-1}
	\STATE $step_p \assign \precommit$
\ENDUPON

\SPACE
\UPON{$2f+1$ $\li{\Precommit,h_p,round_p,*}$ for the first time} \label{line:tab:startTimeoutPrecommit}
	\STATE \textbf{after} $\timeoutPrecommit$ execute $OnTimeoutPrecommit(h_p, round_p)$
\ENDUPON 

\SPACE
\UPON{$\li{\Proposal,h_p,r, v, *}$ \From\ $\coord(h_p,r)$ \textbf{AND} $2f+1$ $\li{\Precommit,h_p,r,id(v)}$ \With\ $decision_p[h_p] = \nil$} \label{line:tab:onDecideRule} 
\IF{$valid(v)$} \label{line:tab:validDecisionValue}
	\STATE $decision_p[h_p] = v$   \label{line:tab:decide} 
	\STATE$h_p \assign h_p + 1$  \label{line:tab:increaseHeight} 
	\STATE reset $lockedRound_p$, $lockedValue_p$ to init values and empty message log 
	\STATE $StartRound(0)$   	
\ENDIF
\ENDUPON

\SHORTSPACE
\UPON{$f+1$ $\li{*,h_p,round, *, *}$ \textbf{with} $round > round_p$} \label{line:tab:skipRounds}
\STATE $StartRound(round)$ \label{line:tab:nextRound2}
\ENDUPON

\SHORTSPACE
\FUNCTION{$OnTimeoutPropose(height,round)$} \label{line:tab:onTimeoutPropose}
\IF{$height = h_p \wedge round = round_p \wedge step_p = \propose$}
\STATE \Broadcast \ $\li{\Prevote,h_p,round_p, \nil}$  \label{line:tab:prevote-nil-on-timeout}	
\STATE $step_p \assign \prevote$
\ENDIF	
\ENDFUNCTION

\SHORTSPACE
\FUNCTION{$OnTimeoutPrevote(height,round)$} \label{line:tab:onTimeoutPrevote}
\IF{$height = h_p \wedge round = round_p \wedge step_p = \prevoteWait$}
\STATE \Broadcast \ $\li{\Precommit,h_p,round_p,\nil}$   \label{line:tab:precommit-nil-onTimeout}
\STATE $step_p \assign \precommit$
\ENDIF	
\ENDFUNCTION

\SHORTSPACE
\FUNCTION{$OnTimeoutPrecommit(height,round)$} \label{line:tab:onTimeoutPrecommit}
\IF{$height = h_p \wedge round = round_p$}
\STATE $StartRound(round_p + 1)$ \label{line:tab:nextRound} 
\ENDIF	
\ENDFUNCTION	
\end{algorithmic}
\caption{Tendermint consensus algorithm}
\label{alg:tendermint}
\end{algorithm}

In this section we present Tendermint Byzantine fault-tolerant consensus algorithm. The algorithm is inspired by the PBFT SMR algorithm~\cite{CL02:tcs} and the DLS algorithm for authenticated faults (the Algorithm 2 from \cite{DLS88:jacm}), but the algorithm structure is quite different in Tendermint\footnote{The comparison with related consensus algorithms is given in Section~\ref{sec:relatedWork}.}. There is only a single mode of execution in Tendermint, i.e., there is no separation between the normal and the recovery mode, which is the case in PBFT-like protocols (e.g., \cite{CL02:tcs}, \cite{Ver09:spinning} or \cite{Cle09:aardvark}). We believe that this makes the protocol simpler to understand and implement correctly.
   
The code of the algorithm is given as Algorithm~\ref{alg:tendermint}. We present the algorithm as a set of \emph{upon rules} that are executed atomically\footnote{In case several rules are active at the same time, the first rule to be executed is picked randomly. The correctness of the algorithm does not depend on the order in which rules are executed.}. We assume that processes exchange protocol messages using gossip protocol and received and sent messages at every process are stored in the local \emph{message log}. An upon rule is triggered once the message log contains messages such that the corresponding condition evaluates to $\tt{true}$. The condition that assumes a reception of $X$ messages of particular type and content, denotes set of messages whose senders have aggregate voting power at least equal to $X$. The variables with index $p$ are process local state variables, while variables without index $p$ are value placeholders. The sign $*$ denotes any value.    

We denote with $n$ the total voting power of processes in the system, and we assume that the total voting power of faulty processes in the system is bounded with a system parameter $f$. 
The algorithm assumes that $n > 3f$, i.e., it requires that the total voting power of faulty processes is smaller than one third of the total voting power. For simplicity we present the algorithm for the case $n = 3f + 1$.

The algorithm proceeds in rounds, where each round has a dedicated \emph{proposer}. The assignment scheme of rounds to proposers is known to all processes and is given as a function $\coord_p(h_p, round_p)$, returning the proposer for the round $round_p$ in the consensus instance $h_p$ at the process $p$. We assume that the proposer selection function is weighted round-robin, where processes are rotated proportional to its voting power\footnote{A validator with more voting power is selected more frequently, proportional to its power. More precisely, during a sequence of rounds of size $n$, every process is proposer in a number of rounds equal to its voting power.}. 

Processes exchange the following messages in Tendermint: $\Proposal$, $\Prevote$ and $\Precommit$. The 
$\Proposal$ message is used by the proposer of the current round to suggest a potential decision value, while 
$\Prevote$ and $\Precommit$ are votes for a proposed value. Tendermint belongs to the class 3 of consensus algorithms (like PBFT \cite{CL02:tcs} and DLS \cite{DLS88:jacm}) according to the classification of consensus algorithms from \cite{RMS10:dsn}, so it requires two voting steps (three communication exchanges in total) to decide a value. The Tendermint consensus algorithm is designed for the blockchain context where a value to decide is a block of transactions (so potentially quite big value). Therefore, in the Algorithm \ref{alg:tendermint} we are explicit about sending a value (block of transactions) and a small, constant size value id (a unique value identifier, normally a hash of the value, i.e., if $\id(v) = \id(v')$, then $v=v'$). The $\Proposal$ message is the only one carrying the value; $\Prevote$ and $\Precommit$ messages carry the value id. 
A correct process decides on a value $v$ in Tendermint upon receiving the $\Proposal$ for $v$ and $2f+1$ voting-power equivalent $\Precommit$ messages for $\id(v)$ in some round $r$. In order to send $\Precommit$ message for $v$ in a round $r$, a correct process waits to receive the $\Proposal$ and $2f+1$ the corresponding $\Prevote$ messages in the round $r$. Otherwise it sends $\Precommit$ message with a special $\nil$ value.  This ensures that correct processes can $\Precommit$ only a single value (or $\nil$) in a round. 
As a proposer might be a faulty process, the proposed value is treated by correct processes as a suggestion (it is not blindly accepted), and a correct process tells others if it accepted the $\Proposal$ for value $v$ by sending $\Prevote$ message for $\id(v)$; otherwise it sends $\Prevote$ message with a special $\nil$ value. 

Every process maintains the following variables in the Algorithm \ref{alg:tendermint}: $step$, $lockedValue$, $lockedRound$, $validValue$ and $validRound$. The $step$ denotes the current state of the internal Tendermint state machine, i.e., it reflects the stage of the algorithm execution in the current round. The $lockedValue$ stores the most recent value (with respect to a round number) for which a $\Precommit$ message has been sent. The $lockedRound$ is the last round in which process sent $\Precommit$ message that is not $\nil$. We also say that a correct process locks a value $v$ in a round $r$ by setting $lockedValue = v$ and $lockedRound = r$ before sending $\Precommit$ message for $\id(v)$. As a correct process can decide a value $v$ only if $2f+1$ $\Precommit$ messages for $\id(v)$ are received, this implies that a possible decision value is a value that is locked by at least $f+1$ voting power equivalent of processes. Therefore, any value $v$ for which $\Proposal$ and $2f+1$ the corresponding $\Prevote$ messages are received in some round $r$ are \emph{possible decision} value. The role of $validValue$ variable is to store the most recent possible decision value; the $validRound$ is the last round in which $validValue$ is updated. Apart from those variables, a process also stores a current height ($h_p$), a current round number ($round_p$), and an array of decisions (Tendermint assumes a sequence of consensus instances) $decision_p$. 

Every round starts by a proposer suggesting a value with $\Proposal$ message (see line \ref{line:tab:send-proposal}). In the initial round of each consensus instance (called \emph{height} in Tendermint), a proposer is free to chose the value to suggest. In the Algorithm~\ref{alg:tendermint}, a correct process obtains a value to propose using an external function    
$getValue()$ that returns a valid value to propose. In the following rounds, a correct proposer will suggest a new value only if $validValue \neq \nil$; otherwise $validValue$ is proposed (see lines~\ref{line:tab:isThereLockedValue}-\ref{line:tab:getValidValue}). Note that if a correct proposer $p$ sends $validValue$ with the $validRound$ in the $\Proposal$, this implies that the process $p$ received $\Proposal$ and the corresponding $2f+1$ $\Prevote$ messages for $lockedValue$ in the round $lockedRound$. In addition to the value proposed, the $\Proposal$ message also contains the value of the $validRound$ so other processes are informed about the last round in which the proposer observed $lockedValue$ as a possible decision value.  
If a correct process sends $\Proposal$ message with $validValue$ ($validRound > -1$) at time $t > GST$, by the \emph{Gossip communication} property, the corresponding $\Proposal$ and the $Prevote$ messages will be received by all correct processes before time $t+\Delta$. Therefore, all correct processes will be able to verify the correctness of the suggested value as it supported by the $\Proposal$ and the corresponding $2f+1$ voting power equivalent $\Prevote$ messages.   

A correct process $p$ accepts the proposal for a value $v$  (send $\Prevote$ for $id(v)$) if an external \emph{valid} function returns $true$
and if $p$ hasn't locked any value ($lockedRound = -1$) or $p$ has locked the value $v$ ($lockedValue = v$); see the line \ref{line:tab:accept-proposal-2}. 
In case the proposed pair is $(v,r)$ and a correct process $p$ has locked some other value ($v' \neq v$), it will accept $v$ only if $v'$ was more recent possible decision value\footnote{As explained above, the possible decision value in a round $r$ is the one for which $\Proposal$ and the corresponding $2f+1$ $\Prevote$ messages are received for the round $r$.} in the round higher than $lockedRound_p$ ($r > lockedValue_p$).   
Otherwise, a correct process will reject the proposal by sending $\Prevote$ message with $\nil$ value. A correct process will send $\Prevote$ message with $\nil$ value also in case $\timeoutPropose$ expired (it is started when a correct process starts a new round) and a process has not sent $\Prevote$ message in the current round yet (see the line \ref{line:tab:onTimeoutPrevote}). 

If a correct process receives $\Proposal$ message for some value $v$ and $2f+1$ $\Prevote$
messages for $\id(v)$, then it sends $\Precommit$ message with $\id(v)$. Otherwise, it sends $\Precommit$ $\nil$. A correct process will send $\Precommit$ message with $\nil$ value also in case $\timeoutPrevote$ expired (it is started when a correct process sent $\Prevote$ message and received any $2f+1$ $\Prevote$ messages)  and a process has not sent $\Precommit$ message in the current round yet (see the line \ref{line:tab:onTimeoutPropose}). 
A correct process decides on some value $v$ if it receives in some round $r$ $\Proposal$ message for $v$ and $2f+1$ $\Precommit$ messages with $\id(v)$ (see the line \ref{line:tab:decide}).  
To prevent algorithm for blocking and waiting forever for this condition to be true, the Algorithm \ref{alg:tendermint} relies also on third timeout, $\timeoutPrecommit$. It is triggered after a process receives any set of $2f+1$ $\Precommit$ messages. If the $\timeoutPrecommit$ expires and a process has not decided yet, the process starts the next round (see the line \ref{line:tab:onTimeoutPrecommit}).  
The timeouts are increased with every new round $r$, i.e, $timeoutX := initTimeoutX + r*timeoutDelta$, and are reset for every new height (consensus instance). Increasing the timeout values ensures that eventually communication between correct processes in a round is reliable and timely, so correct processes can decide. 
 

