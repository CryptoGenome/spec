# Lite client

## Problem statement

We assume that the lite client knows a (base) header *inithead* it trusts (by social consensus or because
the lite client has decided to trust the header before). The goal is to check whether another header
*newhead* can be trusted based on the data in *inithead*.

The correctness of the protocol is based on the assumption that *inithead* was generated by an instance of
Tendermint consensus.

## Definitions

### Data structures

In the following, only the details of the data structures needed for this specification are given.

 ```go
   type Header struct {
        Height   int64
        Time     Time      // the chain time when the header (block) was generated

        // hashes from the app output from the prev block
        ValidatorsHash     []byte        // hash of the validators for the current block
        NextValidatorsHash []byte        // hash of the validators for the next block

        // hashes of block data
       	LastCommitHash []byte            // hash of the commit from validators from the last block
   }

   type SignedHeader struct {
        Header        Header
        Commit        Commit            // commit for the given header
   }

   type ValidatorSet struct {
        Validators         []Validator
        TotalVotingPower   int64
   }

   type Validator struct {
        Address       Address           // validator address (we assume validator's addresses are unique)
        VotingPower   int64             // validator's voting power
   }

   type TrustedState {
        SignedHeader   SignedHeader
        ValidatorSet   ValidatorSet
   }
 ```

### Functions

For the purpose of this lite client specification, we assume that the Tendermint Full Node exposes the following functions over Tendermint RPC:
```go
    // returns signed header: Header with Commit, for the given height
    func Commit(height int64) (SignedHeader, error)

    // returns validator set for the given height
    func Validators(height int64) (ValidatorSet, error)
```

Furthermore, we assume the following auxiliary functions:
```go
    // returns the validator set for the given validator hash
    func validators(validatorsHash []byte) ValidatorSet

    // returns true if commit corresponds to the block data in the header; otherwise false
    func matchingCommit(header Header, commit Commit) bool

    // returns the set of validators from the given validator set that committed the block
    // it does not assume signature verification
    func signers(commit Commit, validatorSet ValidatorSet) []Validator

    // return the voting power the validators in v1 have according to their voting power in set v2
    // it assumes signature verification so it can be computationally expensive
    func votingPowerIn(v1 []Validator, v2 ValidatorSet) int64

    // add this state as trusted to the store
    func add(store Store, trustedState TrustedState) error

    // retrieve the trusted state at given height if it exists (error = nil)
    // return an error if there are no trusted state for the given height
    // if height = 0, return the latest trusted state
    func get(store Store, height int64) (TrustedState, error)
```


**VerifyHeaderAtHeight.**
```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustThreshold TrustThreshold,
                          trustingPeriod Duration,
                          clockDrift Duration,
                          store Store) (error, (TrustedState, Time)) {

    now := System.Time()
    initTrustedState, newTrustedState, err := VerifyAndUpdateNonRecursive(untrustedHeight,
                                                                          trustThreshold,
                                                                          trustingPeriod,
                                                                          clockDrift,
                                                                          now,
                                                                          store Store)

    if err != nil return err

    now = System.Time()
    if !isWithinTrustedPeriod(initTrustedState.SignedHeader.Header, trustingPeriod, now) {
               return ErrHeaderNotWithinTrustedPeriod
    }
    return nil, (newTrustedState, now)
}
```


**VerifyAndUpdateNonRecursive.** TODO.
```go
func VerifyAndUpdateNonRecursive(untrustedHeight int64,
                                 trustThreshold TrustThreshold,
                                 trustingPeriod Duration,
                                 clockDrift Duration,
                                 now Time,
                                 store Store) error {

    // fetch the latest state and ensure it hasn't expired
    trustedState, error = get(store, 0)
    if error != nil return error

    trustedSh = trustedState.SignedHeader
    trustedHeader = trustedSh.Header
    assert trustedHeader.Height < untrustedHeight AND
           trustedHeader.Time < now

    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {
        return ErrHeaderNotWithinTrustedPeriod
    }

    th := trustedHeader // th is trusted header

    untrustedSh, error := Commit(untrustedHeight)
    if error != nil return error

    untrustedHeader = untrustedSh.Header
    assert untrustedHeader.Time < now + clockDrift

    untrustedVs, error := Validators(untrustedHeight)
    if error != nil return error

    untrustedNextVs, error := Validators(untrustedHeight + 1)
    if error != nil return error

    // untrustedHeader is a list of headers that have not passed verifySingle
    untrustedHeaders := [untrustedHeader]

    while true {
        for h in untrustedHeaders {
            // we assume here that iteration is done in the order of header heights
            error = verifySingle(
                         trustedState,
                         untrustedSh,
                         untrustedVs,
                         untrustedNextVs,
                         trustThreshold)

            if err == nil {
                // the untrusted header is now trusted. update the store
                trustedState = TrustedState(untrustedSh, untrustedNextVs)
                add(store, trustedState)

                untrustedHeaders.RemoveHeadersSmallerOrEqual(h.Header.Height)
                if trustedState.SignedHeader.Header == untrustedSh.Header {
                    return nil
                }
            }
            if fatalError(err) { return err }
        }

        endHeight = min(untrustedHeaders)
        while true {
            trustedSh = trustedState.SignedHeader
            trustedHeader = trustedSh.Header
            pivotHeight := ceil((trustedHeader.Height + endHeight) / 2)

            untrustedSh, error := Commit(pivotHeight)
            if error != nil return error

            untrustedHeader = untrustedSh.Header
            assert untrustedHeader.Time < now + clockDrift

            untrustedVs, error := Validators(untrustedHeight)
            if error != nil return error

            untrustedNextVs, error := Validators(untrustedHeight + 1)
            if error != nil return error

            error = verifySingle(
                      trustedState,
                      untrustedSh,
                      untrustedVs,
                      untrustedNextVs,
                      trustThreshold)

            if fatalError(error) return error

            if err == nil {
                trustedState = TrustedState(untrustedSh, untrustedNextVs)
                add(store, trustedState)
                break
            }

            untrustedHeaders.add(untrustedHeader)
            endHeight = pivot
        }
    }
    return nil // this line should never be reached
}
```
